package com.adp.eletter.service;

import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.reset;
import static org.mockito.Mockito.anyLong;

import java.util.Arrays;
import java.util.List;
import java.util.Optional;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.modelmapper.ModelMapper;

import com.adp.eletter.dto.CandidateDTO;
import com.adp.eletter.entitiy.Candidate;
import com.adp.eletter.entitiy.Candidate.OfferLetterStatus;
import com.adp.eletter.exception.CandidateException;
import com.adp.eletter.repository.CandidateRepository;

@ExtendWith(MockitoExtension.class)
public class CandidateServiceImplIntegrationTest {

    @Mock
    private CandidateRepository candidateRepository;

    @InjectMocks
    private CandidateServiceImpl candidateServiceImpl;

    private Candidate candidate1, candidate2;

    @BeforeEach
    public void setUp() {
        candidate1 = new Candidate(12l, "panda", "barenya", "panda@gmail.com", 1000000l, "ADP01", "Male", 9390999755l, "3gds", "wad", OfferLetterStatus.GENERATED, "12gnfc", "yes");
        candidate2 = new Candidate(22l, "nandu", "surendhar", "davu@gmail.com", 1000000l, "ADP01", "Male", 9390999755l, "3ds", "wd", OfferLetterStatus.APPROVED, "12gnfc", "yes");

        List<Candidate> allCandidates = Arrays.asList(candidate1, candidate2);

        Mockito.when(candidateRepository.findById(candidate1.getCandidateId())).thenReturn(Optional.of(candidate1));
        Mockito.when(candidateRepository.findById(candidate2.getCandidateId())).thenReturn(Optional.of(candidate2));
        Mockito.when(candidateRepository.findAll()).thenReturn(allCandidates);
        Mockito.when(candidateRepository.findById(-99L)).thenReturn(Optional.empty());
    }

    @Test
    public void whenValidID_thenCandidateShouldBeFound() throws CandidateException {
        Long id = 22l;
        CandidateDTO found = candidateServiceImpl.getCandidateById(id);
        verifyFindByIdIsCalledOnce();
        assertThat(found.getCandidateId()).isEqualTo(id);
    }

    // Uncommented and refactored this test
    @Test
    public void whenInValidID_thenCandidateShouldNotBeFound() {
        Long id = -99L;
        Exception exception = assertThrows(CandidateException.class, () -> {
            candidateServiceImpl.getCandidateById(id);
        });
        verifyFindByIdIsCalledOnce();
        String expectedMessage = "Candidate Not available";  // Assuming this is the exception message
        String actualMessage = exception.getMessage();
        assertThat(actualMessage).isEqualTo(expectedMessage);
    }

    // ... [other test methods remain largely unchanged]

    // Utility methods to verify interactions
    private void verifyFindByIdIsCalledOnce() {
        verify(candidateRepository, times(1)).findById(anyLong());
        reset(candidateRepository);
    }

    private void verifyFindAllCandidatesIsCalledOnce() {
        verify(candidateRepository, times(1)).findAll();
        reset(candidateRepository);
    }
}
